1. 用于判断第k位是否为1 -> True/False
   (a >> k) & 1
   (1 << k) & a
2. 设置第k位为1 -> new one
   a = a | (1 << k)
3. 设置第k位为0 -> new one
   a = a & ~(1 << k)
4. 消除最后一个1 -> new one
   a = a & (a - 1)
5. 找到最后一个1 -> new one
   n & -n
6. 判断是否为2的指数 (if a number is exponential of two) -> True/False
   if (n <= 0) return false
   return (n & (n - 1)) == 0
7. 判断两个数是否异号
   (x ^ y) < 0 -> True 异号；False 同号
   x ^ y = 0 -> 两个值相等
   x ^ 0 = x; x ^ y = y ^ x
   bin(x ^ y).count('1') -> 计算共有多少bit异号
8. reverse all bit in a number -> new one
   ～a
9. bit_length() 返回一个整数所需要的最小位数来表示它的绝对值(不包括符号位)。
   如果 x 为 0,返回 0
   如果 x 为正数,返回表示该值所需的最少位数(不包括符号位)
   如果 x 为负数,返回表示其绝对值所需的位数加 1(1 用于表示符号位)

# 进制转换
每一位 * n^k
十进制 Decimal -> int
二进制 Binary ->  bin(10)
八进制 Octal ->   oct(10)
十六进制 Hexadecimal -> hex(10)


# 运算符
&: 与
|: 或
^: 异或
~: 取反
X << k: 左移k位，移出位丢弃，右边空位用0补齐
X >> k: 右移k位，移出位丢弃，左边空位根据符号位补齐
X >>> k: 右移K位，移出位丢弃，左边空位用0补齐


# 基础知识
十进制 -> 二进制：用1024循环除以2，将余数逆向排序即可
计算机用二进制：电脑的基层部件是由集成电路组成的，这些集成电路是一个个门电路组成的。当计算机工作的时候，电路通电工作，于是每个输出端就有了电压。
电压的高低通过模数转换即转换成了二进制：高电平是由1表示，低电平由0表示。也就是说将模拟路转换成为数字电路。

# bit, byte, word
1. bit: 是数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。计算机中的CPU位数指的是CPU一次能处理的最大位数，比如32位，64位。
2. Byte: 用大写的“B”表示。 字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。
八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。
3. word: 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。一个字通常由一个或多个（一般是字节的整数位）字节构成。例如286微机的字由2个字节组成，它的字长为16；486微机的字由4个字节组成，
它的字长为32位机。 计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。

1 Byte = 8 bit
1 kB = 10^3 Byte
1 MB = 10^6 Byte
1 GB = 10^9 Byte

# 原码，反码，补码
机器数：计算机中的二进制是带符号的，最高位存放符号, 正数为0, 负数为1. 计算机字长为8位. 
真值：带符号位的机器数对应的真正数值称为机器数的真值

原码：符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值
反码：* 正数的反码是其本身. * 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. 
     # 反码的意义是用于减法：3 - 3 = [00000110] 原+ [10000110]原 = [10001100] = -12 原，用原码计算减法的答案是错误的
补码：* 正数的补码就是其本身. * 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
     # 补码的意义是用于解决两个0的编码问题：+0 = [000000],   -0= [100000] -> 用补码表示：0 表示为 00000000，而 10000000 就是-128
     -128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)
     使用补码, 不仅仅修复了0存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]
     计算机中普遍使用的是补码。

